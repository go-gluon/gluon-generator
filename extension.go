package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"os/exec"
	"sort"
	"strconv"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/go-gluon/gondex"
)

type extInfo struct {
	name     string
	priority int
	version  string
	service  bool
	stru     *gondex.StructInfo
}

func ExtensionGenerator(indexer *gondex.Indexer, config generatorConfig) error {

	pkgPath, _ := os.LookupEnv("GOPACKAGE")
	result := jen.NewFilePath(pkgPath)
	result.PackageComment("Code generated by gluon; DO NOT EDIT.")

	result.Add(jen.Comment("//go:embed resources/*"))
	result.Add(jen.Var().Id("resources").Qual("embed", "FS"))

	impls := indexer.FindInterfaceImplementations("github.com/go-gluon/gluon.Extension")
	if len(impls) == 0 {
		fmt.Printf("No extension found!\n")
		return nil
	}

	// create info about extension
	info := make([]extInfo, len(impls))
	for i, e := range impls {

		// create default values
		ei := extInfo{
			stru:     e,
			version:  e.Package().Data().Module.Version,
			name:     strings.TrimSuffix(strings.ToLower(e.Name()), "extension"),
			priority: 100,
			service:  false,
		}

		fields := e.FieldStructInfo().Fields()
		field, e := fields["Annotation"]
		if e {
			if name, exists := field.TagValue("name"); exists {
				ei.name = name
			}

			if priority, exists := field.TagValue("priority"); exists {
				if value, er := strconv.Atoi(priority); er == nil {
					ei.priority = value
				}
			}

			if service, exists := field.TagValue("service"); exists {
				if value, er := strconv.ParseBool(service); er == nil {
					ei.service = value
				}
			}
		}

		info[i] = ei
	}

	// sort extension base on the priority
	sort.Slice(info, func(i, j int) bool {
		return info[i].priority < info[j].priority
	})

	module := indexer.Module("github.com/go-gluon/gluon")
	gluonVersion := module.Version()

	mainModule := indexer.MainModule()
	appName := mainModule.Name()

	appVersion := "0.0.0"
	if out, err := cmdOutputErr(config, "git", "describe", "--tags"); err == nil {
		appVersion = out
	}

	fmt.Printf("gluon: %v - appVer: %v - app: %v\n", gluonVersion, appVersion, appName)

	list := []jen.Code{}
	for _, t := range info {

		c := jen.Op("&").Qual(t.stru.Package().Data().PkgPath, t.stru.Name()).Op("{}")
		list = append(list, jen.Line().Qual("github.com/go-gluon/gluon", "NewExtension").
			Call(jen.Lit(t.name), jen.Lit(t.priority), jen.Lit(t.version), jen.Lit(t.service), c))
	}
	list = append(list, jen.Line())

	params := []jen.Code{jen.Lit(appName), jen.Lit(appVersion), jen.Lit(gluonVersion), jen.Op("&").Id("resources")}
	params = append(params, list...)

	result.Add(jen.Comment("Create gluon instance"))
	result.Add(jen.Var().Id("g").Op("=").Qual("github.com/go-gluon/gluon", "CreateGluon").Call(params...))

	result.Add(jen.Comment("Main method"))
	result.Add(jen.Func().Id("main").Params().Block(
		jen.Id("g").Op(".").Id("Start").Op("()"),
	))

	createConfigFile(result, config)
	return nil
}

func cmdOutputErr(config generatorConfig, name string, arg ...string) (string, error) {
	if config.debug {
		log.Printf("%v %v", name, strings.Join(arg, " "))
	}
	out, err := exec.Command(name, arg...).CombinedOutput()
	if config.debug {
		log.Printf("Output: %v", string(out))
	}
	return string(bytes.TrimRight(out, "\n")), err
}

func createConfigFile(jen *jen.File, config generatorConfig) {
	filename, _ := os.LookupEnv("GOFILE")
	filename = strings.TrimSuffix(filename, ".go")
	filename = filename + "_gluon.go"

	if config.debug {
		log.Printf("%#v", jen)
		log.Printf("%#v", filename)
		return
	}

	f, err := os.Create(filename)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	_, err = f.WriteString(fmt.Sprintf("%#v", jen))
	if err != nil {
		panic(err)
	}
}
